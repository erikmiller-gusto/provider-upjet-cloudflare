// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type CustomCertBundleInitParameters struct {

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// (String, Sensitive) The key for a custom uploaded certificate.
	// The key for a custom uploaded certificate.
	CustomKeySecretRef v1.SecretKeySelector `json:"customKeySecretRef" tf:"-"`
}

type CustomCertBundleObservation struct {

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`
}

type CustomCertBundleParameters struct {

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate" tf:"custom_certificate,omitempty"`

	// (String, Sensitive) The key for a custom uploaded certificate.
	// The key for a custom uploaded certificate.
	// +kubebuilder:validation:Optional
	CustomKeySecretRef v1.SecretKeySelector `json:"customKeySecretRef" tf:"-"`
}

type CustomHostnameInitParameters struct {

	// hostname (customer) settings.
	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// (String) a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// (String) A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// (String) The custom hostname that will point to your hostname via CNAME.
	// The custom hostname that will point to your hostname via CNAME.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (Attributes) SSL properties used when creating the custom hostname. (see below for nested schema)
	SSL *SSLInitParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// (String) Identifier.
	// Identifier.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-cloudflare/apis/cluster/zone/v1alpha1.Zone
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

type CustomHostnameObservation struct {

	// (String) This is the time the hostname was created.
	// This is the time the hostname was created.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// hostname (customer) settings.
	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// (String) a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// (String) A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// (String) The custom hostname that will point to your hostname via CNAME.
	// The custom hostname that will point to your hostname via CNAME.
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (String) Identifier.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Attributes) This is a record which can be placed to activate a hostname. (see below for nested schema)
	OwnershipVerification *OwnershipVerificationObservation `json:"ownershipVerification,omitempty" tf:"ownership_verification,omitempty"`

	// (Attributes) This presents the token to be served by the given http url to activate a hostname. (see below for nested schema)
	OwnershipVerificationHTTP *OwnershipVerificationHTTPObservation `json:"ownershipVerificationHttp,omitempty" tf:"ownership_verification_http,omitempty"`

	// (Attributes) SSL properties used when creating the custom hostname. (see below for nested schema)
	SSL *SSLObservation `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// (String) Status of the hostname's activation.
	// Available values: "active", "pending", "active_redeploying", "moved", "pending_deletion", "deleted", "pending_blocked", "pending_migration", "pending_provisioned", "test_pending", "test_active", "test_active_apex", "test_blocked", "test_failed", "provisioned", "blocked".
	// Status of the hostname's activation.
	// Available values: "active", "pending", "active_redeploying", "moved", "pending_deletion", "deleted", "pending_blocked", "pending_migration", "pending_provisioned", "test_pending", "test_active", "test_active_apex", "test_blocked", "test_failed", "provisioned", "blocked".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (List of String) These are errors that were encountered while trying to activate a hostname.
	// These are errors that were encountered while trying to activate a hostname.
	VerificationErrors []*string `json:"verificationErrors,omitempty" tf:"verification_errors,omitempty"`

	// (String) Identifier.
	// Identifier.
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type CustomHostnameParameters struct {

	// hostname (customer) settings.
	// Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	CustomMetadata map[string]*string `json:"customMetadata,omitempty" tf:"custom_metadata,omitempty"`

	// (String) a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	// a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
	// +kubebuilder:validation:Optional
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// (String) A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	// A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
	// +kubebuilder:validation:Optional
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// (String) The custom hostname that will point to your hostname via CNAME.
	// The custom hostname that will point to your hostname via CNAME.
	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// (Attributes) SSL properties used when creating the custom hostname. (see below for nested schema)
	// +kubebuilder:validation:Optional
	SSL *SSLParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// (String) Identifier.
	// Identifier.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-cloudflare/apis/cluster/zone/v1alpha1.Zone
	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`

	// Reference to a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDRef *v1.Reference `json:"zoneIdRef,omitempty" tf:"-"`

	// Selector for a Zone in zone to populate zoneId.
	// +kubebuilder:validation:Optional
	ZoneIDSelector *v1.Selector `json:"zoneIdSelector,omitempty" tf:"-"`
}

type OwnershipVerificationHTTPInitParameters struct {
}

type OwnershipVerificationHTTPObservation struct {

	// (String) Token to be served.
	// Token to be served.
	HTTPBody *string `json:"httpBody,omitempty" tf:"http_body,omitempty"`

	// (String) The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
	// The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url,omitempty"`
}

type OwnershipVerificationHTTPParameters struct {
}

type OwnershipVerificationInitParameters struct {
}

type OwnershipVerificationObservation struct {

	// (String) DNS Name for record.
	// DNS Name for record.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// DNS Record type.
	// Available values: "txt".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (String) Content for the record.
	// Content for the record.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type OwnershipVerificationParameters struct {
}

type SSLInitParameters struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// (Boolean) Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	// (Attributes List) Array of custom certificate and key pairs (1 or 2 pairs allowed) (see below for nested schema)
	CustomCertBundle []CustomCertBundleInitParameters `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// (String, Sensitive) The key for a custom uploaded certificate.
	// The key for a custom uploaded certificate.
	CustomKeySecretRef *v1.SecretKeySelector `json:"customKeySecretRef,omitempty" tf:"-"`

	// (String) Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// (Attributes) SSL specific settings. (see below for nested schema)
	Settings *SettingsInitParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// (String) Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Boolean) Indicates whether the certificate covers a wildcard.
	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLObservation struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// (Boolean) Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	// (Attributes List) Array of custom certificate and key pairs (1 or 2 pairs allowed) (see below for nested schema)
	CustomCertBundle []CustomCertBundleObservation `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// (String) Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// (Attributes) SSL specific settings. (see below for nested schema)
	Settings *SettingsObservation `json:"settings,omitempty" tf:"settings,omitempty"`

	// (String) Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Boolean) Indicates whether the certificate covers a wildcard.
	// Indicates whether the certificate covers a wildcard.
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SSLParameters struct {

	// (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
	// Available values: "ubiquitous", "optimal", "force".
	// +kubebuilder:validation:Optional
	BundleMethod *string `json:"bundleMethod,omitempty" tf:"bundle_method,omitempty"`

	// (String) The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	// The Certificate Authority that will issue the certificate
	// Available values: "digicert", "google", "lets_encrypt", "ssl_com".
	// +kubebuilder:validation:Optional
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// (Boolean) Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	// Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
	// +kubebuilder:validation:Optional
	CloudflareBranding *bool `json:"cloudflareBranding,omitempty" tf:"cloudflare_branding,omitempty"`

	// (Attributes List) Array of custom certificate and key pairs (1 or 2 pairs allowed) (see below for nested schema)
	// +kubebuilder:validation:Optional
	CustomCertBundle []CustomCertBundleParameters `json:"customCertBundle,omitempty" tf:"custom_cert_bundle,omitempty"`

	// (String) If a custom uploaded certificate is used.
	// If a custom uploaded certificate is used.
	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// (String, Sensitive) The key for a custom uploaded certificate.
	// The key for a custom uploaded certificate.
	// +kubebuilder:validation:Optional
	CustomKeySecretRef *v1.SecretKeySelector `json:"customKeySecretRef,omitempty" tf:"-"`

	// (String) Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	// Domain control validation (DCV) method used for this hostname.
	// Available values: "http", "txt", "email".
	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// (Attributes) SSL specific settings. (see below for nested schema)
	// +kubebuilder:validation:Optional
	Settings *SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// (String) Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// Level of validation to be used for this hostname. Domain validation (dv) must be used.
	// Available values: "dv".
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// (Boolean) Indicates whether the certificate covers a wildcard.
	// Indicates whether the certificate covers a wildcard.
	// +kubebuilder:validation:Optional
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SettingsInitParameters struct {

	// (List of String) An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// (String) Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// (String) Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// (String) The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// (String) Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

type SettingsObservation struct {

	// (List of String) An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// (String) Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// (String) Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// (String) The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// (String) Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

type SettingsParameters struct {

	// (List of String) An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	// An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// (String) Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	// Whether or not Early Hints is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// (String) Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	// Whether or not HTTP2 is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// (String) The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	// The minimum TLS version supported.
	// Available values: "1.0", "1.1", "1.2", "1.3".
	// +kubebuilder:validation:Optional
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// (String) Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	// Whether or not TLS 1.3 is enabled.
	// Available values: "on", "off".
	// +kubebuilder:validation:Optional
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`
}

// CustomHostnameSpec defines the desired state of CustomHostname
type CustomHostnameSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CustomHostnameParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider CustomHostnameInitParameters `json:"initProvider,omitempty"`
}

// CustomHostnameStatus defines the observed state of CustomHostname.
type CustomHostnameStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CustomHostnameObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// CustomHostname is the Schema for the CustomHostnames API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type CustomHostname struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.hostname) || (has(self.initProvider) && has(self.initProvider.hostname))",message="spec.forProvider.hostname is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ssl) || (has(self.initProvider) && has(self.initProvider.ssl))",message="spec.forProvider.ssl is a required parameter"
	Spec   CustomHostnameSpec   `json:"spec"`
	Status CustomHostnameStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CustomHostnameList contains a list of CustomHostnames
type CustomHostnameList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CustomHostname `json:"items"`
}

// Repository type metadata.
var (
	CustomHostname_Kind             = "CustomHostname"
	CustomHostname_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: CustomHostname_Kind}.String()
	CustomHostname_KindAPIVersion   = CustomHostname_Kind + "." + CRDGroupVersion.String()
	CustomHostname_GroupVersionKind = CRDGroupVersion.WithKind(CustomHostname_Kind)
)

func init() {
	SchemeBuilder.Register(&CustomHostname{}, &CustomHostnameList{})
}
