// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type ConnectionsInitParameters struct {
}

type ConnectionsObservation struct {

	// (String) UUID of the Cloudflare Tunnel connector.
	// UUID of the Cloudflare Tunnel connector.
	ClientID *string `json:"clientId,omitempty" tf:"client_id,omitempty"`

	// (String) The cloudflared version used to establish this connection.
	// The cloudflared version used to establish this connection.
	ClientVersion *string `json:"clientVersion,omitempty" tf:"client_version,omitempty"`

	// (String) The Cloudflare data center used for this connection.
	// The Cloudflare data center used for this connection.
	ColoName *string `json:"coloName,omitempty" tf:"colo_name,omitempty"`

	// (String) UUID of the tunnel.
	// UUID of the Cloudflare Tunnel connection.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Boolean) Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If true, the connection has disconnected but is still being tracked. If false, the connection is actively serving traffic.
	// Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
	IsPendingReconnect *bool `json:"isPendingReconnect,omitempty" tf:"is_pending_reconnect,omitempty"`

	// (String) Timestamp of when the connection was established.
	// Timestamp of when the connection was established.
	OpenedAt *string `json:"openedAt,omitempty" tf:"opened_at,omitempty"`

	// (String) The public IP address of the host running cloudflared.
	// The public IP address of the host running cloudflared.
	OriginIP *string `json:"originIp,omitempty" tf:"origin_ip,omitempty"`

	// (String) UUID of the Cloudflare Tunnel connection.
	// UUID of the Cloudflare Tunnel connection.
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`
}

type ConnectionsParameters struct {
}

type ZeroTrustTunnelCloudflaredInitParameters struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-cloudflare/apis/cluster/account/v1alpha1.Account
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Reference to a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDRef *v1.Reference `json:"accountIdRef,omitempty" tf:"-"`

	// Selector for a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDSelector *v1.Selector `json:"accountIdSelector,omitempty" tf:"-"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// friendly name for a tunnel.
	// A user-friendly name for a tunnel.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	TunnelSecretSecretRef *v1.SecretKeySelector `json:"tunnelSecretSecretRef,omitempty" tf:"-"`
}

type ZeroTrustTunnelCloudflaredObservation struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// (String) Cloudflare account ID
	// Cloudflare account ID
	AccountTag *string `json:"accountTag,omitempty" tf:"account_tag,omitempty"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// (Attributes List, Deprecated) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
	Connections []ConnectionsObservation `json:"connections,omitempty" tf:"connections,omitempty"`

	// (String) Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If null, the tunnel is inactive.
	// Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
	ConnsActiveAt *string `json:"connsActiveAt,omitempty" tf:"conns_active_at,omitempty"`

	// (String) Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If null, the tunnel is active.
	// Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
	ConnsInactiveAt *string `json:"connsInactiveAt,omitempty" tf:"conns_inactive_at,omitempty"`

	// (String) Timestamp of when the resource was created.
	// Timestamp of when the resource was created.
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
	// Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
	DeletedAt *string `json:"deletedAt,omitempty" tf:"deleted_at,omitempty"`

	// (String) UUID of the tunnel.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) Metadata associated with the tunnel.
	// Metadata associated with the tunnel.
	Metadata *string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// friendly name for a tunnel.
	// A user-friendly name for a tunnel.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean, Deprecated) If true, the tunnel can be configured remotely from the Zero Trust dashboard. If false, the tunnel must be configured locally on the origin machine.
	// If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
	RemoteConfig *bool `json:"remoteConfig,omitempty" tf:"remote_config,omitempty"`

	// (String) The status of the tunnel. Valid values are inactive (tunnel has never been run), degraded (tunnel is active and able to serve traffic but in an unhealthy state), healthy (tunnel is active and able to serve traffic), or down (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
	// Available values: "inactive", "degraded", "healthy", "down".
	// The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
	// Available values: "inactive", "degraded", "healthy", "down".
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// (String) The type of tunnel.
	// Available values: "cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni".
	// The type of tunnel.
	// Available values: "cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni".
	TunType *string `json:"tunType,omitempty" tf:"tun_type,omitempty"`
}

type ZeroTrustTunnelCloudflaredParameters struct {

	// (String) Cloudflare account ID
	// Cloudflare account ID
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-cloudflare/apis/cluster/account/v1alpha1.Account
	// +kubebuilder:validation:Optional
	AccountID *string `json:"accountId,omitempty" tf:"account_id,omitempty"`

	// Reference to a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDRef *v1.Reference `json:"accountIdRef,omitempty" tf:"-"`

	// Selector for a Account in account to populate accountId.
	// +kubebuilder:validation:Optional
	AccountIDSelector *v1.Selector `json:"accountIdSelector,omitempty" tf:"-"`

	// (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	// Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
	// Available values: "local", "cloudflare".
	// +kubebuilder:validation:Optional
	ConfigSrc *string `json:"configSrc,omitempty" tf:"config_src,omitempty"`

	// friendly name for a tunnel.
	// A user-friendly name for a tunnel.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
	// +kubebuilder:validation:Optional
	TunnelSecretSecretRef *v1.SecretKeySelector `json:"tunnelSecretSecretRef,omitempty" tf:"-"`
}

// ZeroTrustTunnelCloudflaredSpec defines the desired state of ZeroTrustTunnelCloudflared
type ZeroTrustTunnelCloudflaredSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ZeroTrustTunnelCloudflaredParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider ZeroTrustTunnelCloudflaredInitParameters `json:"initProvider,omitempty"`
}

// ZeroTrustTunnelCloudflaredStatus defines the observed state of ZeroTrustTunnelCloudflared.
type ZeroTrustTunnelCloudflaredStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ZeroTrustTunnelCloudflaredObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// ZeroTrustTunnelCloudflared is the Schema for the ZeroTrustTunnelCloudflareds API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflare}
type ZeroTrustTunnelCloudflared struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   ZeroTrustTunnelCloudflaredSpec   `json:"spec"`
	Status ZeroTrustTunnelCloudflaredStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ZeroTrustTunnelCloudflaredList contains a list of ZeroTrustTunnelCloudflareds
type ZeroTrustTunnelCloudflaredList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ZeroTrustTunnelCloudflared `json:"items"`
}

// Repository type metadata.
var (
	ZeroTrustTunnelCloudflared_Kind             = "ZeroTrustTunnelCloudflared"
	ZeroTrustTunnelCloudflared_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ZeroTrustTunnelCloudflared_Kind}.String()
	ZeroTrustTunnelCloudflared_KindAPIVersion   = ZeroTrustTunnelCloudflared_Kind + "." + CRDGroupVersion.String()
	ZeroTrustTunnelCloudflared_GroupVersionKind = CRDGroupVersion.WithKind(ZeroTrustTunnelCloudflared_Kind)
)

func init() {
	SchemeBuilder.Register(&ZeroTrustTunnelCloudflared{}, &ZeroTrustTunnelCloudflaredList{})
}
